rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
  
    // Helper functions
    function isAuth() {
      return request.auth != null;
    }

    function isUserInCompany(companyId) {
      return isAuth() && request.auth.token.companyId == companyId;
    }

    function hasRole(allowedRoles) {
      return isAuth() && request.auth.token.role in allowedRoles;
    }

    // Global Collections
    match /invites/{inviteId} {
      allow read: if isAuth();
      allow create: if hasRole(['owner', 'admin']);
      allow update: if isAuth(); // User accepting the invite
    }

    // Company-scoped collections
    match /companies/{companyId} {
    
      function isInCompany() {
        return isUserInCompany(companyId);
      }

      function hasCompanyRole(allowedRoles) {
        return isInCompany() && request.auth.token.role in allowedRoles;
      }
      
      // All reads within a company require the user to be part of that company.
      allow read: if isInCompany();

      match /users/{userId} {
        allow write: if hasCompanyRole(['owner', 'admin']);
      }
      
      match /customers/{customerId} {
        allow write: if hasCompanyRole(['owner', 'admin', 'dispatcher']);
      }

      match /jobs/{jobId} {
        allow create, update: if hasCompanyRole(['owner', 'admin', 'dispatcher']);
        allow delete: if hasCompanyRole(['owner', 'admin']);
      }

      match /invoices/{invoiceId} {
         allow create, update: if hasCompanyRole(['owner', 'admin', 'accountant', 'dispatcher']);
         allow delete: if hasCompanyRole(['owner', 'admin']);
      }

      match /payments/{paymentId} {
        // Payments are only created via a trusted server (Cloud Function)
        allow write: if false;
      }

      match /settings/{docId} {
        allow write: if hasCompanyRole(['owner', 'admin']);
      }
      
      // Default deny for any other subcollections
      match /{allChildren=**} {
        allow write: if false;
      }
    }

    // Deny all other top-level collection access
    match /{path=**} {
        allow read, write: if false;
    }
  }
}